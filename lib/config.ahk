global _ResolvedIniPath := ""
global _HotkeyConfig := Map()

; Converts a relative path to absolute based on a reference file or dir.
ResolvePath(path, reference := "") {
    if (path = "")
        return ""
    path := StrReplace(path, "/", "\")
    if RegExMatch(path, "^[A-Za-z]:\\") || SubStr(path, 1, 2) = "\\\\"
        return path

    baseDir := ""
    if (reference = "") {
        baseDir := A_ScriptDir
    } else if DirExist(reference) {
        baseDir := reference
    } else {
        SplitPath(reference, , &baseDir)
        if !baseDir
            baseDir := A_ScriptDir
    }
    baseDir := RTrim(StrReplace(baseDir, "/", "\"), "\\")
    if !baseDir
        baseDir := A_ScriptDir

    if SubStr(path, 1, 1) = "\\" {
        drive := SubStr(baseDir, 1, 2)
        return drive path
    }
    return baseDir "\" LTrim(path, "\\")
}

; Resolves the ini file path, honoring overrides stored inside it.
GetIniPath() {
    global _ResolvedIniPath
    if (_ResolvedIniPath != "")
        return _ResolvedIniPath

    defaultPath := A_ScriptDir "\prompter.ini"
    path := defaultPath
    try {
        override := IniRead(defaultPath, "Files", "IniPath", "")
        if override {
            candidate := ResolvePath(override, defaultPath)
            if FileExist(candidate)
                path := candidate
        }
    } catch {
        ; ignore and fall back to default
    }
    _ResolvedIniPath := path
    return path
}

; Maintains a shim include file that redirects to a configured UIA library.
EnsureUiaInclude() {
    shimPath := A_ScriptDir "\uiashim.ahk"
    configPath := GetIniPath()
    override := ""
    try override := IniRead(configPath, "Files", "UIALib", "")
    override := Trim(override)

    desired := ""
    if (override != "") {
        resolved := ResolvePath(override, configPath)
        if !FileExist(resolved)
            throw Error("Configured UIA override not found:`n" resolved)
        quote := Chr(34)
        escaped := StrReplace(resolved, quote, quote quote)
        desired := "; Auto-generated by elgatoPrompter.ahk`n#Include *i " . quote . escaped . quote . "`n"
    }

    current := ""
    if FileExist(shimPath)
        current := FileRead(shimPath, "UTF-8")

    if (desired = "") {
        if (current != "") {
            try FileDelete(shimPath)
            return true
        }
        return false
    }

    if (current = desired)
        return false

    if FileExist(shimPath)
        try FileDelete(shimPath)

    FileAppend(desired, shimPath, "UTF-8")
    return true
}

; Reloads the script when the UIA shim changes.
RestartForShim() {
    Reload()
}

; Loads runtime configuration and builds control specs from the INI file.
LoadConfigOverrides() {
    global INI, APP_EXE, WIN_CLASS_RX, DEBUG_LOG, BASE_STEP, APPLY_DELAY_MS, SHOW_PATH_TIP
    global MAX_ANCESTOR_DEPTH, SUBTREE_LIST_LIMIT, SCAN_LIST_LIMIT, SLIDER_SCAN_LIMIT, TOOLTIP_HIDE_DELAY_MS
    global DEBUG_VERBOSE_LOGGING, ENABLE_PROBE_SCANS
    global _ControlSpecs

    SplitPath(INI, , &iniDir)

    APP_EXE := IniRead(INI, "App", "Executable", APP_EXE)
    WIN_CLASS_RX := IniRead(INI, "App", "ClassRegex", WIN_CLASS_RX)

    debugLogOverride := IniRead(INI, "Files", "DebugLog", DEBUG_LOG)
    DEBUG_LOG := ResolvePath(debugLogOverride, iniDir ? iniDir : A_ScriptDir)

    APPLY_DELAY_MS := IniReadNumber(INI, "Behavior", "ApplyDelayMs", APPLY_DELAY_MS)
    SHOW_PATH_TIP := IniReadBool(INI, "Behavior", "ShowPathTip", SHOW_PATH_TIP)
    BASE_STEP := IniReadNumber(INI, "Behavior", "BaseStep", BASE_STEP)

    ENABLE_PROBE_SCANS := IniReadBool(INI, "Debug", "ProbeScans", ENABLE_PROBE_SCANS)
    DEBUG_VERBOSE_LOGGING := IniReadBool(INI, "Debug", "VerboseLogging", DEBUG_VERBOSE_LOGGING)

    MAX_ANCESTOR_DEPTH := IniReadNumber(INI, "Diagnostics", "MaxAncestorDepth", MAX_ANCESTOR_DEPTH)
    SUBTREE_LIST_LIMIT := IniReadNumber(INI, "Diagnostics", "SubtreeLimit", SUBTREE_LIST_LIMIT)
    SCAN_LIST_LIMIT := IniReadNumber(INI, "Diagnostics", "ScanLimit", SCAN_LIST_LIMIT)
    SLIDER_SCAN_LIMIT := IniReadNumber(INI, "Diagnostics", "SliderScanLimit", SLIDER_SCAN_LIMIT)
    TOOLTIP_HIDE_DELAY_MS := IniReadNumber(INI, "UI", "TooltipHideDelayMs", TOOLTIP_HIDE_DELAY_MS)

    percentPerStep := IniReadNumber(INI, "Scroll", "PercentPerStep", 5)

    controlMeta := [
        Map("Name", "brightness", "AutoKey", "Brightness", "Label", "Brightness", "Handler", ApplyRangeValueDelta),
        Map("Name", "contrast", "AutoKey", "Contrast", "Label", "Contrast", "Handler", ApplyRangeValueDelta),
        Map("Name", "scrollspeed", "AutoKey", "ScrollSpeed", "Label", "Scroll speed", "Handler", ApplyRangeValueDelta),
        Map("Name", "fontsize", "AutoKey", "FontSize", "Label", "Font size", "Handler", ApplyRangeValueDelta),
        Map("Name", "scroll", "AutoKey", "ScrollViewport", "Label", "Scroll", "Handler", ApplyScrollDelta, "Resolver", FindPrompterViewport, "PercentPerStep", percentPerStep)
    ]

    stepsSection := "ControlSteps"
    invertSection := "ControlInvert"

    specs := Map()
    for meta in controlMeta {
        name := meta["Name"]
        autoId := IniRead(INI, "Automation", meta["AutoKey"], "")
        step := IniReadNumber(INI, stepsSection, name, BASE_STEP)
        invert := IniReadBool(INI, invertSection, name, false)

        spec := Map(
            "Name", name,
            "DisplayName", meta["Label"],
            "Handler", meta["Handler"],
            "Step", step
        )

        if autoId
            spec["AutoId"] := autoId
        if meta.Has("Resolver")
            spec["Resolver"] := meta["Resolver"]
        if meta.Has("PercentPerStep")
            spec["PercentPerStep"] := meta["PercentPerStep"]
        if invert
            spec["Invert"] := true

        specs[name] := spec
    }

    _ControlSpecs := specs

    LoadHotkeyConfig()
}

; Returns the cached map of control specifications.
GetControlSpecs() {
    global _ControlSpecs
    return _ControlSpecs
}

; Loads hotkey overrides from the INI file and caches them.
LoadHotkeyConfig() {
    global INI, _HotkeyConfig
    defaults := Map(
        "ScrollUp", "F13",
        "ScrollDown", "F14",
        "ScrollSpeedDown", "F18",
        "ScrollSpeedUp", "F19",
        "BrightnessDown", "^!d",
        "BrightnessUp", "^!a",
        "ContrastDown", "^!e",
        "ContrastUp", "^!q"
    )

    cfg := Map()
    for key, defVal in defaults {
        val := Trim(IniRead(INI, "Hotkeys", key, defVal))
        cfg[key] := val
    }

    _HotkeyConfig := cfg
    UpdateIniHotkeyComment(cfg)
    return cfg
}

; Returns the currently cached hotkey configuration map.
GetHotkeyConfig() {
    global _HotkeyConfig
    return _HotkeyConfig
}

IsAutoHotkeyHeaderLine(line) {
    static prefixes := [
        "; [AUTO] Elgato Prompter hotkey summary",
        "; Elgato Prompter configuration.",
        "; Scroll viewport slower/faster:",
        "; Scroll speed down/up:",
        "; Brightness down/up:",
        "; Contrast down/up:",
        "; Edit the [Hotkeys] section below to customize bindings.",
        "; Ctrl+Alt+S",
        "; Ctrl+Alt+Z",
        "; Ctrl+Alt+U/M/W/P",
        "; Ctrl+Alt+F",
        "; Ctrl+Alt+C",
        "; Ctrl+Alt+G",
        "; Ctrl+Alt+H",
        "; Ctrl+Alt+X",
        "; The help dialog also shows this file path and log location.",
        "; Quick reference:",
        ";   F13/F14",
        ";   F18/F19",
        ";   Ctrl+Alt+D/A",
        ";   Ctrl+Alt+E/Q",
        ";   Ctrl+Alt+S",
        ";   Ctrl+Alt+Z",
        ";   Ctrl+Alt+G"
    ]
    for prefix in prefixes {
        if (prefix != "" && InStr(line, prefix) = 1)
            return true
    }
    return false
}

; Refreshes the prompter.ini header comment to list the active hotkeys.
UpdateIniHotkeyComment(cfg) {
    global INI
    if (INI = "")
        return

    commentLines := [
        "[AUTO] Elgato Prompter hotkey summary",
        Format("Scroll viewport slower/faster: {}/{}", cfg["ScrollUp"], cfg["ScrollDown"]),
        Format("Scroll speed down/up: {}/{}", cfg["ScrollSpeedDown"], cfg["ScrollSpeedUp"]),
        Format("Brightness down/up: {}/{}", cfg["BrightnessDown"], cfg["BrightnessUp"]),
        Format("Contrast down/up: {}/{}", cfg["ContrastDown"], cfg["ContrastUp"]),
        "Edit the [Hotkeys] section below to customize bindings.",
        "Ctrl+Alt+S -> Save spinner calibration",
        "Ctrl+Alt+Z -> Copy debug info",
        "Ctrl+Alt+U/M/W/P -> Diagnostic dumps",
        "Ctrl+Alt+F -> Quick scan counts",
        "Ctrl+Alt+C -> List candidate windows",
        "Ctrl+Alt+G -> Toggle probe scans",
        "Ctrl+Alt+H -> Show help",
        "Ctrl+Alt+X -> Exit script",
        "The help dialog also shows this file path and log location."
    ]

    newBlock := "; " JoinLines(commentLines)
    newBlock := RegExReplace(newBlock, "\R", "`r`n; ")

    try {
        txt := FileRead(INI, "UTF-8")
    } catch {
        return
    }

    delimiter := "`r`n`r`n"
    pos := InStr(txt, delimiter)
    header := pos ? SubStr(txt, 1, pos - 1) : ""
    rest := pos ? SubStr(txt, pos + StrLen(delimiter)) : txt

    if (header = "")
        return

    userLines := []
    autoLinesFound := false
    for rawLine in StrSplit(header, "`n") {
        line := RTrim(rawLine, "`r")
        if (line = "") {
            userLines.Push(line)
            continue
        }
        if IsAutoHotkeyHeaderLine(line) {
            autoLinesFound := true
        } else {
            userLines.Push(line)
        }
    }

    if !autoLinesFound
        return

    userHeader := ""
    for line in userLines {
        if (userHeader != "")
            userHeader .= "`r`n"
        userHeader .= line
    }

    finalHeader := userHeader
    if (userHeader != "")
        finalHeader .= "`r`n"
    finalHeader .= newBlock

    currentHeader := RTrim(header, "`r`n")
    desiredHeader := RTrim(finalHeader, "`r`n")
    if (currentHeader = desiredHeader)
        return

    newContent := finalHeader "`r`n`r`n" rest
    tempPath := INI ".tmp"
    try FileDelete(tempPath)
    try {
        FileAppend(newContent, tempPath, "UTF-8")
        FileMove(tempPath, INI, true)
    } catch {
        try FileDelete(tempPath)
    }
}
